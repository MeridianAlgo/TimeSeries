/**
 * Mathematical Utilities
 *
 * Core mathematical functions and utilities for financial calculations.
 */
/**
 * Mathematical utility functions
 */
export declare class MathUtils {
    /**
     * Calculate the natural logarithm with safety checks
     */
    static safeLog(value: number): number;
    /**
     * Calculate square root with safety checks
     */
    static safeSqrt(value: number): number;
    /**
     * Calculate percentage change between two values
     */
    static percentageChange(oldValue: number, newValue: number): number;
    /**
     * Calculate log returns
     */
    static logReturn(price1: number, price2: number): number;
    /**
     * Calculate simple returns
     */
    static simpleReturn(price1: number, price2: number): number;
    /**
     * Calculate compound annual growth rate (CAGR)
     */
    static cagr(beginValue: number, endValue: number, periods: number): number;
    /**
     * Calculate annualized return
     */
    static annualizeReturn(totalReturn: number, periods: number, periodsPerYear?: number): number;
    /**
     * Calculate annualized volatility
     */
    static annualizeVolatility(volatility: number, periodsPerYear?: number): number;
    /**
     * Linear interpolation
     */
    static linearInterpolate(x0: number, y0: number, x1: number, y1: number, x: number): number;
    /**
     * Clamp value between min and max
     */
    static clamp(value: number, min: number, max: number): number;
    /**
     * Check if number is approximately equal (within tolerance)
     */
    static isApproximatelyEqual(a: number, b: number, tolerance?: number): boolean;
    /**
     * Round to specified decimal places
     */
    static roundTo(value: number, decimals: number): number;
    /**
     * Calculate factorial
     */
    static factorial(n: number): number;
    /**
     * Calculate combination (n choose k)
     */
    static combination(n: number, k: number): number;
    /**
     * Calculate permutation (n P k)
     */
    static permutation(n: number, k: number): number;
    /**
     * Calculate greatest common divisor
     */
    static gcd(a: number, b: number): number;
    /**
     * Calculate least common multiple
     */
    static lcm(a: number, b: number): number;
    /**
     * Generate array of numbers from start to end with step
     */
    static range(start: number, end: number, step?: number): number[];
    /**
     * Generate linearly spaced array
     */
    static linspace(start: number, end: number, num: number): number[];
    /**
     * Generate logarithmically spaced array
     */
    static logspace(start: number, end: number, num: number, base?: number): number[];
    /**
     * Calculate moving average
     */
    static movingAverage(data: number[], window: number): number[];
    /**
     * Calculate exponential moving average
     */
    static exponentialMovingAverage(data: number[], alpha: number): number[];
    /**
     * Calculate weighted moving average
     */
    static weightedMovingAverage(data: number[], weights: number[]): number[];
    /**
     * Calculate rolling correlation
     */
    static rollingCorrelation(x: number[], y: number[], window: number): number[];
    /**
     * Calculate Pearson correlation coefficient
     */
    static correlation(x: number[], y: number[]): number;
    /**
     * Calculate covariance
     */
    static covariance(x: number[], y: number[]): number;
    /**
     * Calculate beta coefficient
     */
    static beta(returns: number[], marketReturns: number[]): number;
    /**
     * Calculate variance
     */
    static variance(data: number[]): number;
    /**
     * Normalize array to [0, 1] range
     */
    static normalize(data: number[]): number[];
    /**
     * Standardize array (z-score normalization)
     */
    static standardize(data: number[]): number[];
}
//# sourceMappingURL=MathUtils.d.ts.map