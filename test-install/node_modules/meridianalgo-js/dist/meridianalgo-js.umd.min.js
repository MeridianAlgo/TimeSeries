!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).MeridianAlgo={})}(this,function(e){"use strict";class t{static validateMarketData(e){const t=[],a=[];return Array.isArray(e)?0===e.length?(t.push({code:"EMPTY_DATA",message:"Data array cannot be empty",severity:"critical"}),{isValid:!1,errors:t,warnings:a}):(e.forEach((e,r)=>{this.validateSingleMarketData(e,r,t,a)}),this.validateChronologicalOrder(e,t,a),this.validateDataGaps(e,a),this.validateOutliers(e,a),{isValid:0===t.length,errors:t,warnings:a}):(t.push({code:"INVALID_TYPE",message:"Data must be an array",severity:"critical"}),{isValid:!1,errors:t,warnings:a})}static validateSingleMarketData(e,t,a,r){const i=`Item ${t}`;e.timestamp||a.push({code:"MISSING_TIMESTAMP",message:`${i}: Missing timestamp`,field:"timestamp",severity:"high"}),e.symbol&&"string"==typeof e.symbol||a.push({code:"INVALID_SYMBOL",message:`${i}: Invalid or missing symbol`,field:"symbol",value:e.symbol,severity:"high"});["open","high","low","close","volume"].forEach(t=>{const r=e[t];"number"==typeof r&&isFinite(r)?r<0&&"close"!==t&&a.push({code:"NEGATIVE_VALUE",message:`${i}: ${t} cannot be negative`,field:t,value:r,severity:"medium"}):a.push({code:"INVALID_NUMERIC_FIELD",message:`${i}: ${t} must be a finite number`,field:t,value:r,severity:"high"})}),"number"==typeof e.high&&"number"==typeof e.low&&e.high<e.low&&a.push({code:"INVALID_HIGH_LOW",message:`${i}: High price cannot be less than low price`,severity:"high"}),"number"==typeof e.open&&"number"==typeof e.high&&"number"==typeof e.low&&(e.open>e.high||e.open<e.low)&&r.push({code:"OPEN_OUT_OF_RANGE",message:`${i}: Open price is outside high-low range`,field:"open",value:e.open}),"number"==typeof e.close&&"number"==typeof e.high&&"number"==typeof e.low&&(e.close>e.high||e.close<e.low)&&r.push({code:"CLOSE_OUT_OF_RANGE",message:`${i}: Close price is outside high-low range`,field:"close",value:e.close}),void 0!==e.vwap&&("number"==typeof e.vwap&&isFinite(e.vwap)||r.push({code:"INVALID_VWAP",message:`${i}: VWAP must be a finite number`,field:"vwap",value:e.vwap})),void 0!==e.trades&&(!Number.isInteger(e.trades)||e.trades<0)&&r.push({code:"INVALID_TRADES",message:`${i}: Trades must be a non-negative integer`,field:"trades",value:e.trades})}static validateChronologicalOrder(e,t,a){for(let r=1;r<e.length;r++){const i=new Date(e[r-1].timestamp).getTime(),s=new Date(e[r].timestamp).getTime();s<i?t.push({code:"NON_CHRONOLOGICAL",message:`Data is not in chronological order at index ${r}`,severity:"medium"}):s===i&&a.push({code:"DUPLICATE_TIMESTAMP",message:`Duplicate timestamp at index ${r}`,value:e[r].timestamp})}}static validateDataGaps(e,t){if(e.length<2)return;const a=[];for(let t=1;t<e.length;t++){const r=new Date(e[t-1].timestamp).getTime(),i=new Date(e[t].timestamp).getTime();a.push(i-r)}const r=new Map;a.forEach(e=>{r.set(e,(r.get(e)||0)+1)});let i=0,s=0;for(const[e,t]of r)t>s&&(s=t,i=e);a.forEach((e,a)=>{e>2*i&&t.push({code:"DATA_GAP",message:`Large data gap detected between index ${a} and ${a+1}`,value:e})})}static validateOutliers(e,t){if(e.length<10)return;const a=[];for(let t=1;t<e.length;t++){const r=e[t-1].close,i=e[t].close;r>0&&a.push((i-r)/r)}if(0===a.length)return;const r=a.reduce((e,t)=>e+t,0)/a.length,i=a.reduce((e,t)=>e+Math.pow(t-r,2),0)/(a.length-1),s=Math.sqrt(i);0!==s&&a.forEach((e,a)=>{Math.abs((e-r)/s)>3&&t.push({code:"PRICE_OUTLIER",message:`Potential price outlier detected at index ${a+1}`,value:e})})}static validateTrainingData(e){const t=this.validateMarketData(e),a=[...t.errors],r=[...t.warnings];return e.forEach((e,t)=>{void 0!==e.features&&(Array.isArray(e.features)?e.features.forEach((e,r)=>{"number"==typeof e&&isFinite(e)||a.push({code:"INVALID_FEATURE_VALUE",message:`Item ${t}: Feature ${r} must be a finite number`,field:`features[${r}]`,value:e,severity:"medium"})}):a.push({code:"INVALID_FEATURES",message:`Item ${t}: Features must be an array`,field:"features",severity:"medium"})),void 0!==e.target&&("number"==typeof e.target&&isFinite(e.target)||a.push({code:"INVALID_TARGET",message:`Item ${t}: Target must be a finite number`,field:"target",value:e.target,severity:"medium"}))}),{isValid:0===a.length,errors:a,warnings:r}}static validateFeatures(e){const t=[],a=[];return Array.isArray(e)?0===e.length?(t.push({code:"EMPTY_FEATURES",message:"Features array cannot be empty",severity:"high"}),{isValid:!1,errors:t,warnings:a}):(e.forEach((e,a)=>{"number"!=typeof e?t.push({code:"INVALID_FEATURE_TYPE",message:`Feature ${a} must be a number`,field:`features[${a}]`,value:e,severity:"high"}):isFinite(e)||t.push({code:"INVALID_FEATURE_VALUE",message:`Feature ${a} must be finite`,field:`features[${a}]`,value:e,severity:"high"})}),{isValid:0===t.length,errors:t,warnings:a}):(t.push({code:"INVALID_TYPE",message:"Features must be an array",severity:"critical"}),{isValid:!1,errors:t,warnings:a})}static validatePortfolioWeights(e){const t=[],a=[];if(!Array.isArray(e))return t.push({code:"INVALID_TYPE",message:"Weights must be an array",severity:"critical"}),{isValid:!1,errors:t,warnings:a};if(0===e.length)return t.push({code:"EMPTY_WEIGHTS",message:"Weights array cannot be empty",severity:"high"}),{isValid:!1,errors:t,warnings:a};let r=0;e.forEach((e,i)=>{"number"==typeof e&&isFinite(e)?(r+=e,e<0&&a.push({code:"NEGATIVE_WEIGHT",message:`Weight ${i} is negative (short position)`,field:`weights[${i}]`,value:e})):t.push({code:"INVALID_WEIGHT_VALUE",message:`Weight ${i} must be a finite number`,field:`weights[${i}]`,value:e,severity:"high"})});return Math.abs(r-1)>1e-6&&(Math.abs(r-1)>.01?t.push({code:"WEIGHTS_SUM_ERROR",message:`Weights sum to ${r}, should sum to 1.0`,severity:"medium"}):a.push({code:"WEIGHTS_SUM_WARNING",message:`Weights sum to ${r}, should sum to 1.0`,value:r})),{isValid:0===t.length,errors:t,warnings:a}}static validateDateRange(e,t){const a=[],r=[];if(e instanceof Date&&!isNaN(e.getTime())||a.push({code:"INVALID_START_DATE",message:"Start date must be a valid Date object",field:"startDate",severity:"high"}),t instanceof Date&&!isNaN(t.getTime())||a.push({code:"INVALID_END_DATE",message:"End date must be a valid Date object",field:"endDate",severity:"high"}),0===a.length){e>=t&&a.push({code:"INVALID_DATE_RANGE",message:"Start date must be before end date",severity:"high"});t>new Date&&r.push({code:"FUTURE_END_DATE",message:"End date is in the future",field:"endDate",value:t});const i=(t.getTime()-e.getTime())/864e5;i<1&&r.push({code:"SHORT_DATE_RANGE",message:"Date range is less than 1 day",value:i})}return{isValid:0===a.length,errors:a,warnings:r}}static validateNumericParameter(e,t,a={}){const r=[],i=[];return"number"!=typeof e?(r.push({code:"INVALID_TYPE",message:`${t} must be a number`,field:t,value:e,severity:"high"}),{isValid:!1,errors:r,warnings:i}):isFinite(e)?(a.integer&&!Number.isInteger(e)&&r.push({code:"NOT_INTEGER",message:`${t} must be an integer`,field:t,value:e,severity:"medium"}),a.positive&&e<=0&&r.push({code:"NOT_POSITIVE",message:`${t} must be positive`,field:t,value:e,severity:"medium"}),void 0!==a.min&&e<a.min&&r.push({code:"BELOW_MINIMUM",message:`${t} must be at least ${a.min}`,field:t,value:e,severity:"medium"}),void 0!==a.max&&e>a.max&&r.push({code:"ABOVE_MAXIMUM",message:`${t} must be at most ${a.max}`,field:t,value:e,severity:"medium"}),{isValid:0===r.length,errors:r,warnings:i}):(r.push({code:"INVALID_VALUE",message:`${t} must be finite`,field:t,value:e,severity:"high"}),{isValid:!1,errors:r,warnings:i})}static sanitizeMarketData(e){return e.filter(e=>e&&"number"==typeof e.open&&isFinite(e.open)&&"number"==typeof e.high&&isFinite(e.high)&&"number"==typeof e.low&&isFinite(e.low)&&"number"==typeof e.close&&isFinite(e.close)&&"number"==typeof e.volume&&isFinite(e.volume)&&e.high>=e.low).map(e=>({...e,timestamp:new Date(e.timestamp),open:Number(e.open),high:Number(e.high),low:Number(e.low),close:Number(e.close),volume:Number(e.volume),vwap:void 0!==e.vwap?Number(e.vwap):void 0,trades:void 0!==e.trades?Math.floor(Number(e.trades)):void 0})).sort((e,t)=>e.timestamp.getTime()-t.timestamp.getTime())}}class a{static mean(e){if(0===e.length)throw new Error("Cannot calculate mean of empty array");return e.reduce((e,t)=>e+t,0)/e.length}static median(e){if(0===e.length)throw new Error("Cannot calculate median of empty array");const t=[...e].sort((e,t)=>e-t),a=Math.floor(t.length/2);return t.length%2==0?(t[a-1]+t[a])/2:t[a]}static mode(e){if(0===e.length)throw new Error("Cannot calculate mode of empty array");const t=new Map;let a=0;for(const r of e){const e=(t.get(r)||0)+1;t.set(r,e),a=Math.max(a,e)}const r=[];for(const[e,i]of t)i===a&&r.push(e);return r}static standardDeviation(e,t=!0){if(0===e.length)throw new Error("Cannot calculate standard deviation of empty array");if(t&&1===e.length)throw new Error("Cannot calculate sample standard deviation with only one data point");const a=this.mean(e),r=e.map(e=>Math.pow(e-a,2)).reduce((e,t)=>e+t,0)/(t?e.length-1:e.length);return Math.sqrt(r)}static variance(e,t=!0){if(0===e.length)throw new Error("Cannot calculate variance of empty array");if(t&&1===e.length)throw new Error("Cannot calculate sample variance with only one data point");const a=this.mean(e);return e.map(e=>Math.pow(e-a,2)).reduce((e,t)=>e+t,0)/(t?e.length-1:e.length)}static skewness(e){if(e.length<3)throw new Error("Need at least 3 data points to calculate skewness");const t=this.mean(e),a=this.standardDeviation(e),r=e.length;if(0===a)return 0;return r/((r-1)*(r-2))*e.map(e=>Math.pow((e-t)/a,3)).reduce((e,t)=>e+t,0)}static kurtosis(e,t=!0){if(e.length<4)throw new Error("Need at least 4 data points to calculate kurtosis");const a=this.mean(e),r=this.standardDeviation(e),i=e.length;if(0===r)return t?-3:0;const s=i*(i+1)/((i-1)*(i-2)*(i-3))*e.map(e=>Math.pow((e-a)/r,4)).reduce((e,t)=>e+t,0)-3*Math.pow(i-1,2)/((i-2)*(i-3));return t?s:s+3}static quantile(e,t){if(0===e.length)throw new Error("Cannot calculate quantile of empty array");if(t<0||t>1)throw new Error("Quantile must be between 0 and 1");const a=[...e].sort((e,t)=>e-t),r=t*(a.length-1);if(Number.isInteger(r))return a[r];{const e=Math.floor(r),t=Math.ceil(r),i=r-e;return a[e]*(1-i)+a[t]*i}}static interquartileRange(e){const t=this.quantile(e,.25);return this.quantile(e,.75)-t}static detectOutliers(e,t=1.5){const a=this.quantile(e,.25),r=this.quantile(e,.75),i=r-a,s=a-t*i,n=r+t*i,o=[],l=[];return e.forEach((e,t)=>{(e<s||e>n)&&(o.push(e),l.push(t))}),{outliers:o,indices:l}}static zScores(e){const t=this.mean(e),a=this.standardDeviation(e);return 0===a?e.map(()=>0):e.map(e=>(e-t)/a)}static rollingStatistic(e,t,a){if(t<=0||t>e.length)throw new Error("Invalid window size");const r=[];for(let i=t-1;i<e.length;i++){const s=e.slice(i-t+1,i+1);switch(a){case"mean":r.push(this.mean(s));break;case"std":r.push(this.standardDeviation(s));break;case"var":r.push(this.variance(s));break;case"min":r.push(Math.min(...s));break;case"max":r.push(Math.max(...s));break;case"median":r.push(this.median(s));break;case"skewness":r.push(s.length>=3?this.skewness(s):0);break;case"kurtosis":r.push(s.length>=4?this.kurtosis(s):0);break;default:throw new Error(`Unknown statistic: ${a}`)}}return r}static valueAtRisk(e,t=.95){if(t<=0||t>=1)throw new Error("Confidence level must be between 0 and 1");return-this.quantile(e,1-t)}static expectedShortfall(e,t=.95){const a=this.valueAtRisk(e,t),r=e.filter(e=>e<=-a);return 0===r.length?a:-this.mean(r)}static maxDrawdown(e){if(0===e.length)throw new Error("Cannot calculate max drawdown of empty array");let t=e[0],a=0,r=0,i=0;for(let s=1;s<e.length;s++){e[s]>t&&(t=e[s],r=s);const n=(t-e[s])/t;n>a&&(a=n,i=s)}return{maxDrawdown:a,peak:r,trough:i}}static sharpeRatio(e,t=0){const a=e.map(e=>e-t),r=this.mean(a),i=this.standardDeviation(a);return 0===i?r>0?1/0:r<0?-1/0:0:r/i}static sortinoRatio(e,t=0,a=0){const r=e.map(e=>e-t),i=this.mean(r),s=e.filter(e=>e<a);if(0===s.length)return i>0?1/0:0;const n=Math.sqrt(s.reduce((e,t)=>e+Math.pow(t-a,2),0)/s.length);return 0===n?i>0?1/0:0:i/n}static calmarRatio(e){const t=this.cumulativeSum(e),a=t[t.length-1],{maxDrawdown:r}=this.maxDrawdown(t);return 0===r?a>0?1/0:0:a/r}static cumulativeSum(e){const t=[];let a=0;for(const r of e)a+=r,t.push(a);return t}static cumulativeProduct(e){const t=[];let a=1;for(const r of e)a*=1+r,t.push(a-1);return t}static sum(e){return e.reduce((e,t)=>e+t,0)}static product(e){return e.reduce((e,t)=>e*t,1)}static range(e){if(0===e.length)throw new Error("Cannot calculate range of empty array");return Math.max(...e)-Math.min(...e)}static coefficientOfVariation(e){const t=this.mean(e),a=this.standardDeviation(e);if(0===t)throw new Error("Cannot calculate coefficient of variation when mean is zero");return a/Math.abs(t)}static jarqueBeraTest(e){if(e.length<4)throw new Error("Need at least 4 data points for Jarque-Bera test");const t=e.length,a=this.skewness(e),r=this.kurtosis(e,!0),i=t/6*(Math.pow(a,2)+Math.pow(r,2)/4),s=1-this.chiSquareCDF(i,2);return{statistic:i,pValue:s,isNormal:s>.05}}static chiSquareCDF(e,t){return e<=0?0:2===t?1-Math.exp(-e/2):Math.min(1,e/(2*t))}static autocorrelation(e,t){if(t>=e.length||t<0)throw new Error("Invalid lag for autocorrelation calculation");const a=e.length-t,r=e.slice(0,a),i=e.slice(t,t+a),s=this.mean(r),n=this.mean(i);let o=0,l=0,c=0;for(let e=0;e<a;e++){const t=r[e]-s,a=i[e]-n;o+=t*a,l+=t*t,c+=a*a}const h=Math.sqrt(l*c);return 0===h?0:o/h}static autocorrelationFunction(e,t){const a=[];for(let r=0;r<=t;r++)0===r?a.push(1):a.push(this.autocorrelation(e,r));return a}}class r{static safeLog(e){if(e<=0)throw new Error(`Cannot calculate log of non-positive value: ${e}`);return Math.log(e)}static safeSqrt(e){if(e<0)throw new Error(`Cannot calculate square root of negative value: ${e}`);return Math.sqrt(e)}static percentageChange(e,t){return 0===e?0===t?0:1/0:(t-e)/Math.abs(e)}static logReturn(e,t){if(e<=0||t<=0)throw new Error("Prices must be positive for log return calculation");return Math.log(t/e)}static simpleReturn(e,t){if(0===e)throw new Error("Initial price cannot be zero for simple return calculation");return(t-e)/e}static cagr(e,t,a){if(e<=0||t<=0)throw new Error("Values must be positive for CAGR calculation");if(a<=0)throw new Error("Periods must be positive for CAGR calculation");return Math.pow(t/e,1/a)-1}static annualizeReturn(e,t,a=252){return Math.pow(1+e,a/t)-1}static annualizeVolatility(e,t=252){return e*Math.sqrt(t)}static linearInterpolate(e,t,a,r,i){return a===e?t:t+(r-t)*(i-e)/(a-e)}static clamp(e,t,a){return Math.min(Math.max(e,t),a)}static isApproximatelyEqual(e,t,a=1e-10){return Math.abs(e-t)<a}static roundTo(e,t){const a=Math.pow(10,t);return Math.round(e*a)/a}static factorial(e){if(e<0||!Number.isInteger(e))throw new Error("Factorial is only defined for non-negative integers");if(0===e||1===e)return 1;let t=1;for(let a=2;a<=e;a++)t*=a;return t}static combination(e,t){if(t>e||t<0||!Number.isInteger(e)||!Number.isInteger(t))throw new Error("Invalid parameters for combination calculation");if(0===t||t===e)return 1;let a=1;for(let r=0;r<t;r++)a=a*(e-r)/(r+1);return Math.round(a)}static permutation(e,t){if(t>e||t<0||!Number.isInteger(e)||!Number.isInteger(t))throw new Error("Invalid parameters for permutation calculation");let a=1;for(let r=0;r<t;r++)a*=e-r;return a}static gcd(e,t){for(e=Math.abs(Math.floor(e)),t=Math.abs(Math.floor(t));0!==t;){const a=t;t=e%t,e=a}return e}static lcm(e,t){return Math.abs(e*t)/this.gcd(e,t)}static range(e,t,a=1){const r=[];if(a>0)for(let i=e;i<t;i+=a)r.push(i);else if(a<0)for(let i=e;i>t;i+=a)r.push(i);return r}static linspace(e,t,a){if(a<=0)throw new Error("Number of points must be positive");if(1===a)return[e];const r=[],i=(t-e)/(a-1);for(let t=0;t<a;t++)r.push(e+t*i);return r}static logspace(e,t,a,r=10){return this.linspace(e,t,a).map(e=>Math.pow(r,e))}static movingAverage(e,t){if(t<=0||t>e.length)throw new Error("Invalid window size for moving average");const a=[];for(let r=t-1;r<e.length;r++){const i=e.slice(r-t+1,r+1).reduce((e,t)=>e+t,0);a.push(i/t)}return a}static exponentialMovingAverage(e,t){if(t<=0||t>1)throw new Error("Alpha must be between 0 and 1 for EMA calculation");const a=[];let r=e[0];a.push(r);for(let i=1;i<e.length;i++)r=t*e[i]+(1-t)*r,a.push(r);return a}static weightedMovingAverage(e,t){if(0===t.length)throw new Error("Weights array cannot be empty");const a=t.length,r=t.reduce((e,t)=>e+t,0);if(Math.abs(r)<1e-10)throw new Error("Sum of weights cannot be zero");const i=[];for(let s=a-1;s<e.length;s++){let n=0;for(let r=0;r<a;r++)n+=e[s-a+1+r]*t[r];i.push(n/r)}return i}static rollingCorrelation(e,t,a){if(e.length!==t.length)throw new Error("Arrays must have the same length for correlation calculation");if(a<=1||a>e.length)throw new Error("Invalid window size for rolling correlation");const r=[];for(let i=a-1;i<e.length;i++){const s=e.slice(i-a+1,i+1),n=t.slice(i-a+1,i+1),o=this.correlation(s,n);r.push(o)}return r}static correlation(e,t){if(e.length!==t.length||0===e.length)throw new Error("Arrays must have the same non-zero length for correlation calculation");const a=e.length,r=e.reduce((e,t)=>e+t,0),i=t.reduce((e,t)=>e+t,0),s=e.reduce((e,a,r)=>e+a*t[r],0),n=e.reduce((e,t)=>e+t*t,0),o=t.reduce((e,t)=>e+t*t,0),l=a*s-r*i,c=Math.sqrt((a*n-r*r)*(a*o-i*i));return Math.abs(c)<1e-10?0:l/c}static covariance(e,t){if(e.length!==t.length||0===e.length)throw new Error("Arrays must have the same non-zero length for covariance calculation");const a=e.length,r=e.reduce((e,t)=>e+t,0)/a,i=t.reduce((e,t)=>e+t,0)/a;let s=0;for(let n=0;n<a;n++)s+=(e[n]-r)*(t[n]-i);return s/(a-1)}static beta(e,t){const a=this.covariance(e,t),r=this.variance(t);if(Math.abs(r)<1e-10)throw new Error("Market variance is zero, cannot calculate beta");return a/r}static variance(e){if(0===e.length)throw new Error("Cannot calculate variance of empty array");const t=e.reduce((e,t)=>e+t,0)/e.length;return e.map(e=>Math.pow(e-t,2)).reduce((e,t)=>e+t,0)/(e.length-1)}static normalize(e){if(0===e.length)return[];const t=Math.min(...e),a=Math.max(...e)-t;return 0===a?e.map(()=>0):e.map(e=>(e-t)/a)}static standardize(e){if(0===e.length)return[];const t=e.reduce((e,t)=>e+t,0)/e.length,a=Math.sqrt(this.variance(e));return 0===a?e.map(()=>0):e.map(e=>(e-t)/a)}}const i={targetErrorRate:.01,ensembleSize:10,featureCount:1e3,trainingRatio:.8,crossValidationFolds:5,hyperparameterTuning:!0,parallelProcessing:!0,cacheFeatures:!0,incrementalLearning:!1,updateFrequency:"batch",predictionHorizon:1,confidenceThreshold:.8},s={targetFeatureCount:1e3,enableAdvancedFeatures:!0,enableMicrostructure:!0,enableVolatilityFeatures:!0,enableStatisticalFeatures:!0,enableHarmonicFeatures:!0,enableCrossAssetFeatures:!1,lookbackPeriods:[5,10,20,50,100,200],technicalIndicators:{rsi:{periods:[7,14,21,28]},macd:{fast:12,slow:26,signal:9},bollinger:{period:20,multiplier:2},stochastic:{kPeriod:14,dPeriod:3},williams:{period:14},cci:{period:20}}},n={predictor:i,features:s,optimizer:{objective:"sharpe",constraints:{minWeight:0,maxWeight:1,minTotalWeight:.99,maxTotalWeight:1.01,longOnly:!0},riskModel:"historical",optimizationMethod:"quadratic",rebalanceFrequency:"monthly"},performance:{enableParallelProcessing:!0,maxWorkers:4,cacheSize:1e3,memoryLimit:536870912,enableProfiling:!1},validation:{strictMode:!0,autoSanitize:!0,warningsAsErrors:!1},logging:{level:"info",enableConsole:!0,enableFile:!1,maxLogSize:10485760}};class o{static sma(e,t){if(t<=0||t>e.length)throw new Error("Invalid period for SMA calculation");return r.movingAverage(e,t)}static ema(e,t){if(t<=0)throw new Error("Period must be positive for EMA calculation");const a=2/(t+1);return r.exponentialMovingAverage(e,a)}static wma(e,t){if(t<=0||t>e.length)throw new Error("Invalid period for WMA calculation");const a=Array.from({length:t},(e,t)=>t+1);return r.weightedMovingAverage(e,a)}static rsi(e,t=14){if(t<=0||e.length<t+1)throw new Error("Insufficient data or invalid period for RSI calculation");const a=[];for(let t=1;t<e.length;t++)a.push(e[t]-e[t-1]);const r=a.map(e=>Math.max(e,0)),i=a.map(e=>Math.max(-e,0)),s=this.sma(r,t),n=this.sma(i,t),o=[];for(let e=0;e<s.length;e++)if(0===n[e])o.push(100);else{const t=s[e]/n[e];o.push(100-100/(1+t))}return o}static macd(e,t=12,a=26,r=9){if(t>=a)throw new Error("Fast period must be less than slow period for MACD");const i=this.ema(e,t),s=this.ema(e,a),n=a-t,o=i.slice(n).map((e,t)=>e-s[t]),l=this.ema(o,r),c=o.slice(o.length-l.length),h=c.map((e,t)=>e-l[t]);return{macd:c,signal:l,histogram:h}}static bollingerBands(e,t=20,r=2){if(t<=0||t>e.length)throw new Error("Invalid period for Bollinger Bands calculation");const i=this.sma(e,t),s=[],n=[],o=[],l=[];for(let c=0;c<i.length;c++){const h=e.slice(c,c+t),u=a.standardDeviation(h),d=i[c]+r*u,m=i[c]-r*u;s.push(d),n.push(m),o.push((d-m)/i[c]);const g=e[c+t-1];l.push((g-m)/(d-m))}return{upper:s,middle:i,lower:n,bandwidth:o,percentB:l}}static stochastic(e,t,a,r=14,i=3){if(e.length!==t.length||t.length!==a.length)throw new Error("High, low, and close arrays must have the same length");const s=[];for(let i=r-1;i<a.length;i++){const n=Math.max(...e.slice(i-r+1,i+1)),o=Math.min(...t.slice(i-r+1,i+1));n===o?s.push(50):s.push((a[i]-o)/(n-o)*100)}const n=this.sma(s,i);return{k:s.slice(s.length-n.length),d:n}}static williamsR(e,t,a,r=14){if(e.length!==t.length||t.length!==a.length)throw new Error("High, low, and close arrays must have the same length");const i=[];for(let s=r-1;s<a.length;s++){const n=Math.max(...e.slice(s-r+1,s+1)),o=Math.min(...t.slice(s-r+1,s+1));n===o?i.push(-50):i.push((n-a[s])/(n-o)*-100)}return i}static cci(e,t,r,i=20){if(e.length!==t.length||t.length!==r.length)throw new Error("High, low, and close arrays must have the same length");const s=e.map((e,a)=>(e+t[a]+r[a])/3),n=[];for(let e=i-1;e<s.length;e++){const t=s.slice(e-i+1,e+1),r=a.mean(t),o=t.reduce((e,t)=>e+Math.abs(t-r),0)/i;0===o?n.push(0):n.push((s[e]-r)/(.015*o))}return n}static atr(e,t,a,r=14){if(e.length!==t.length||t.length!==a.length)throw new Error("High, low, and close arrays must have the same length");const i=[];for(let r=1;r<e.length;r++){const s=e[r]-t[r],n=Math.abs(e[r]-a[r-1]),o=Math.abs(t[r]-a[r-1]);i.push(Math.max(s,n,o))}return this.sma(i,r)}static adx(e,t,a,r=14){if(e.length!==t.length||t.length!==a.length)throw new Error("High, low, and close arrays must have the same length");const i=[],s=[],n=[];for(let r=1;r<e.length;r++){const o=e[r]-e[r-1],l=t[r-1]-t[r];i.push(o>l&&o>0?o:0),s.push(l>o&&l>0?l:0);const c=e[r]-t[r],h=Math.abs(e[r]-a[r-1]),u=Math.abs(t[r]-a[r-1]);n.push(Math.max(c,h,u))}const o=this.sma(i,r),l=this.sma(s,r),c=this.sma(n,r),h=o.map((e,t)=>e/c[t]*100),u=l.map((e,t)=>e/c[t]*100),d=h.map((e,t)=>{const a=e+u[t];return 0===a?0:Math.abs(e-u[t])/a*100}),m=this.sma(d,r);return{adx:m,plusDI:h.slice(h.length-m.length),minusDI:u.slice(u.length-m.length)}}static mfi(e,t,a,r,i=14){if(e.length!==t.length||t.length!==a.length||a.length!==r.length)throw new Error("All arrays must have the same length");const s=e.map((e,r)=>(e+t[r]+a[r])/3),n=s.map((e,t)=>e*r[t]),o=[];for(let e=i;e<s.length;e++){let t=0,a=0;for(let r=e-i+1;r<=e;r++)s[r]>s[r-1]?t+=n[r]:s[r]<s[r-1]&&(a+=n[r]);if(0===a)o.push(100);else{const e=t/a;o.push(100-100/(1+e))}}return o}static obv(e,t){if(e.length!==t.length)throw new Error("Close and volume arrays must have the same length");const a=[t[0]];for(let r=1;r<e.length;r++)e[r]>e[r-1]?a.push(a[r-1]+t[r]):e[r]<e[r-1]?a.push(a[r-1]-t[r]):a.push(a[r-1]);return a}static vwap(e,t,a,r){if(e.length!==t.length||t.length!==a.length||a.length!==r.length)throw new Error("All arrays must have the same length");const i=e.map((e,r)=>(e+t[r]+a[r])/3),s=[];let n=0,o=0;for(let e=0;e<i.length;e++)n+=i[e]*r[e],o+=r[e],s.push(0===o?i[e]:n/o);return s}static momentum(e,t=10){if(t<=0||t>=e.length)throw new Error("Invalid period for momentum calculation");const a=[];for(let r=t;r<e.length;r++)a.push(e[r]-e[r-t]);return a}static roc(e,t=10){if(t<=0||t>=e.length)throw new Error("Invalid period for ROC calculation");const a=[];for(let r=t;r<e.length;r++)0===e[r-t]?a.push(0):a.push((e[r]-e[r-t])/e[r-t]*100);return a}static standardDeviation(e,t){if(t<=0||t>e.length)throw new Error("Invalid period for standard deviation calculation");return a.rollingStatistic(e,t,"std")}static variance(e,t){if(t<=0||t>e.length)throw new Error("Invalid period for variance calculation");return a.rollingStatistic(e,t,"var")}static linearRegressionSlope(e,t){if(t<=1||t>e.length)throw new Error("Invalid period for linear regression slope calculation");const a=[];for(let r=t-1;r<e.length;r++){const i=e.slice(r-t+1,r+1),s=Array.from({length:t},(e,t)=>t),n=t,o=s.reduce((e,t)=>e+t,0),l=i.reduce((e,t)=>e+t,0),c=(n*s.reduce((e,t,a)=>e+t*i[a],0)-o*l)/(n*s.reduce((e,t)=>e+t*t,0)-o*o);a.push(c)}return a}static pivotPoints(e,t,a){const r=(e+t+a)/3;return{pivot:r,r1:2*r-t,r2:r+(e-t),r3:e+2*(r-t),s1:2*r-e,s2:r-(e-t),s3:t-2*(e-r)}}static extractPrices(e,t){return e.map(e=>e[t])}static extractOHLCV(e){return{open:e.map(e=>e.open),high:e.map(e=>e.high),low:e.map(e=>e.low),close:e.map(e=>e.close),volume:e.map(e=>e.volume)}}}e.DEFAULT_CONFIG=n,e.FeatureEngineer=class{constructor(e={}){this.featureNames=[],this.featureMetadata=[],this.options={...s,...e}}generateFeatures(e){if(e.length<50)throw new Error("Insufficient data for feature generation. Need at least 50 periods.");console.log(`🔧 Generating advanced features from ${e.length} data points...`),this.featureNames=[],this.featureMetadata=[];const t=[];for(let a=0;a<e.length;a++)t.push([]);return this.addBasicFeatures(e,t),this.addTechnicalIndicators(e,t),this.options.enableStatisticalFeatures&&this.addStatisticalFeatures(e,t),this.options.enableVolatilityFeatures&&this.addVolatilityFeatures(e,t),this.addCrossSectionalFeatures(e,t),this.addPatternFeatures(e,t),this.options.enableHarmonicFeatures&&this.addHarmonicFeatures(e,t),console.log(`✨ Generated ${this.featureNames.length} features`),{data:t,featureNames:[...this.featureNames],metadata:[...this.featureMetadata],columns:this.featureNames.length,rows:t.length}}getFeatureNames(){return[...this.featureNames]}getFeatureMetadata(){return[...this.featureMetadata]}addBasicFeatures(e,t){const a=e.map(e=>e.close),r=e.map(e=>e.high),i=e.map(e=>e.low),s=e.map(e=>e.open),n=e.map(e=>e.volume),o=this.calculateReturns(a),l=this.calculateLogReturns(a),c=r.map((e,t)=>e/i[t]),h=s.map((e,t)=>e/a[t]),u=s.map((e,t)=>Math.abs(a[t]-e)/e),d=r.map((e,t)=>(e-Math.max(s[t],a[t]))/a[t]),m=i.map((e,t)=>(Math.min(s[t],a[t])-e)/a[t]);this.addFeatureColumn(t,o,"returns","Basic price returns"),this.addFeatureColumn(t,l,"log_returns","Logarithmic returns"),this.addFeatureColumn(t,c,"hl_ratio","High/Low ratio"),this.addFeatureColumn(t,h,"oc_ratio","Open/Close ratio"),this.addFeatureColumn(t,u,"body_size","Candle body size"),this.addFeatureColumn(t,d,"upper_shadow","Upper shadow size"),this.addFeatureColumn(t,m,"lower_shadow","Lower shadow size");const g=this.calculateReturns(n),p=this.calculateRollingCorrelation(o,g,20),f=this.calculateMovingAverage(n,20),w=n.map((e,t)=>t>=20?e/f[t-20]:1);this.addFeatureColumn(t,g,"volume_returns","Volume returns"),this.addFeatureColumn(t,p,"price_volume_corr","Price-volume correlation"),this.addFeatureColumn(t,w,"volume_ratio","Volume ratio to MA")}addTechnicalIndicators(e,t){const a=e.map(e=>e.close),r=e.map(e=>e.high),i=e.map(e=>e.low),s=e.map(e=>e.volume);for(const e of this.options.technicalIndicators.rsi.periods){const r=o.rsi(a,e),i=this.calculateVelocity(r),s=this.calculateVelocity(i);this.addFeatureColumn(t,r,`rsi_${e}`,`RSI with period ${e}`),this.addFeatureColumn(t,i,`rsi_velocity_${e}`,`RSI velocity ${e}`),this.addFeatureColumn(t,s,`rsi_acceleration_${e}`,`RSI acceleration ${e}`)}const n=o.macd(a,this.options.technicalIndicators.macd.fast,this.options.technicalIndicators.macd.slow,this.options.technicalIndicators.macd.signal);this.addFeatureColumn(t,n.macd,"macd_line","MACD line"),this.addFeatureColumn(t,n.signal,"macd_signal","MACD signal"),this.addFeatureColumn(t,n.histogram,"macd_histogram","MACD histogram");const l=o.bollingerBands(a,this.options.technicalIndicators.bollinger.period,this.options.technicalIndicators.bollinger.multiplier);this.addFeatureColumn(t,l.upper,"bb_upper","Bollinger upper band"),this.addFeatureColumn(t,l.middle,"bb_middle","Bollinger middle band"),this.addFeatureColumn(t,l.lower,"bb_lower","Bollinger lower band"),this.addFeatureColumn(t,l.percentB,"bb_position","Bollinger band position"),this.addFeatureColumn(t,l.bandwidth,"bb_width","Bollinger band width");const c=o.stochastic(r,i,a,this.options.technicalIndicators.stochastic.kPeriod,this.options.technicalIndicators.stochastic.dPeriod);this.addFeatureColumn(t,c.k,"stoch_k","Stochastic %K"),this.addFeatureColumn(t,c.d,"stoch_d","Stochastic %D");const h=o.williamsR(r,i,a,this.options.technicalIndicators.williams.period);this.addFeatureColumn(t,h,"williams_r","Williams %R");const u=o.cci(r,i,a,this.options.technicalIndicators.cci.period);this.addFeatureColumn(t,u,"cci","Commodity Channel Index");const d=o.atr(r,i,a,14);this.addFeatureColumn(t,d,"atr","Average True Range");const m=o.adx(r,i,a,14);this.addFeatureColumn(t,m.adx,"adx","Average Directional Index"),this.addFeatureColumn(t,m.plusDI,"plus_di","Plus Directional Indicator"),this.addFeatureColumn(t,m.minusDI,"minus_di","Minus Directional Indicator");const g=o.obv(a,s),p=o.mfi(r,i,a,s,14);this.addFeatureColumn(t,g,"obv","On-Balance Volume"),this.addFeatureColumn(t,p,"mfi","Money Flow Index")}addStatisticalFeatures(e,t){const r=e.map(e=>e.close),i=this.calculateReturns(r);for(const s of this.options.lookbackPeriods)if(s<=e.length){const e=a.rollingStatistic(i,s,"mean");this.addFeatureColumn(t,e,`rolling_mean_${s}`,`Rolling mean ${s}`);const n=a.rollingStatistic(i,s,"std");this.addFeatureColumn(t,n,`rolling_std_${s}`,`Rolling std ${s}`);const o=a.rollingStatistic(i,s,"skewness");this.addFeatureColumn(t,o,`rolling_skew_${s}`,`Rolling skewness ${s}`);const l=a.rollingStatistic(i,s,"kurtosis");this.addFeatureColumn(t,l,`rolling_kurt_${s}`,`Rolling kurtosis ${s}`);const c=a.rollingStatistic(r,s,"min"),h=a.rollingStatistic(r,s,"max");this.addFeatureColumn(t,c,`rolling_min_${s}`,`Rolling min ${s}`),this.addFeatureColumn(t,h,`rolling_max_${s}`,`Rolling max ${s}`)}for(let e=1;e<=10;e++){const a=this.calculateRollingAutocorrelation(i,e,50);this.addFeatureColumn(t,a,`autocorr_${e}`,`Autocorrelation lag ${e}`)}}addVolatilityFeatures(e,t){const a=e.map(e=>e.close),r=e.map(e=>e.high),i=e.map(e=>e.low),s=this.calculateReturns(a);for(const e of[10,20,50]){const a=this.calculateRollingVolatility(s,e);this.addFeatureColumn(t,a,`cc_vol_${e}`,`Close-to-close volatility ${e}`);const n=this.calculateParkinsonVolatility(r,i,e);this.addFeatureColumn(t,n,`park_vol_${e}`,`Parkinson volatility ${e}`);const o=this.calculateRollingVolatility(a,Math.min(e,20));this.addFeatureColumn(t,o,`vol_of_vol_${e}`,`Volatility of volatility ${e}`)}const n=this.calculateGARCHVolatility(s);this.addFeatureColumn(t,n,"garch_vol","GARCH-like volatility");const o=this.detectVolatilityRegime(s,50);this.addFeatureColumn(t,o,"vol_regime","Volatility regime")}addCrossSectionalFeatures(e,t){const a=e.map(e=>e.close),r=e.map(e=>e.volume),i=this.calculateReturns(a);for(const e of[20,50]){const a=this.calculateRollingRanks(i,e),s=this.calculateRollingRanks(r,e);this.addFeatureColumn(t,a,`return_rank_${e}`,`Return rank ${e}`),this.addFeatureColumn(t,s,`volume_rank_${e}`,`Volume rank ${e}`)}for(const e of[20,50]){const a=this.calculateRollingZScores(i,e),s=this.calculateRollingZScores(r,e);this.addFeatureColumn(t,a,`return_zscore_${e}`,`Return z-score ${e}`),this.addFeatureColumn(t,s,`volume_zscore_${e}`,`Volume z-score ${e}`)}}addPatternFeatures(e,t){const a=e.map(e=>e.close),r=e.map(e=>e.high),i=e.map(e=>e.low),s=e.map(e=>e.open),n=this.detectDoji(s,a),o=this.detectHammer(s,r,i,a),l=this.detectEngulfing(s,a);this.addFeatureColumn(t,n,"doji","Doji pattern"),this.addFeatureColumn(t,o,"hammer","Hammer pattern"),this.addFeatureColumn(t,l,"engulfing","Engulfing pattern");const c=this.detectSupportResistance(a,20);this.addFeatureColumn(t,c.support,"support_level","Support level"),this.addFeatureColumn(t,c.resistance,"resistance_level","Resistance level");const h=this.calculateTrendStrength(a,20);this.addFeatureColumn(t,h,"trend_strength","Trend strength")}addHarmonicFeatures(e,t){const a=e.map(e=>e.close),r=this.calculateReturns(a),i=this.calculateFourierFeatures(r,50);for(let e=0;e<i.length;e++)this.addFeatureColumn(t,i[e],`fourier_${e}`,`Fourier component ${e}`);const s=this.calculateCyclicalFeatures(a);for(let e=0;e<s.length;e++)this.addFeatureColumn(t,s[e],`cyclical_${e}`,`Cyclical component ${e}`)}addFeatureColumn(e,t,a,r){const i=new Array(e.length).fill(0),s=Math.max(0,e.length-t.length);for(let a=0;a<t.length&&s+a<e.length;a++)i[s+a]=isFinite(t[a])?t[a]:0;for(let t=0;t<e.length;t++)e[t].push(i[t]);this.featureNames.push(a),this.featureMetadata.push({name:a,category:"technical",description:r,dataType:"numeric",missingValueStrategy:"zero"})}calculateReturns(e){const t=[];for(let a=1;a<e.length;a++)0!==e[a-1]?t.push((e[a]-e[a-1])/e[a-1]):t.push(0);return t}calculateLogReturns(e){const t=[];for(let a=1;a<e.length;a++)e[a-1]>0&&e[a]>0?t.push(Math.log(e[a]/e[a-1])):t.push(0);return t}calculateVelocity(e){const t=[];for(let a=1;a<e.length;a++)t.push(e[a]-e[a-1]);return t}calculateMovingAverage(e,t){return o.sma(e,t)}calculateRollingCorrelation(e,t,a){return r.rollingCorrelation(e,t,a)}calculateRollingVolatility(e,t){return a.rollingStatistic(e,t,"std")}calculateParkinsonVolatility(e,t,a){const r=e.map((e,a)=>Math.log(e/t[a])),i=[];for(let e=a-1;e<r.length;e++){const t=r.slice(e-a+1,e+1).reduce((e,t)=>e+t*t,0)/(4*Math.log(2)*a);i.push(Math.sqrt(t))}return i}calculateGARCHVolatility(e){const t=[];let a=.01;for(const r of e)a=1e-6+.1*r*r+.85*a,t.push(Math.sqrt(a));return t}detectVolatilityRegime(e,t){const r=this.calculateRollingVolatility(e,t),i=a.mean(r),s=a.standardDeviation(r);return r.map(e=>e>i+s?2:e<i-s?0:1)}calculateRollingRanks(e,t){const a=[];for(let r=t-1;r<e.length;r++){const i=e.slice(r-t+1,r+1),s=e[r],n=i.filter(e=>e<=s).length/t;a.push(n)}return a}calculateRollingZScores(e,t){const r=[];for(let i=t-1;i<e.length;i++){const s=e.slice(i-t+1,i+1),n=a.mean(s),o=a.standardDeviation(s);o>0?r.push((e[i]-n)/o):r.push(0)}return r}calculateRollingAutocorrelation(e,t,a){const i=[];for(let s=a-1;s<e.length-t;s++){const n=e.slice(s-a+1,s+1),o=e.slice(s-a+1+t,s+1+t);if(n.length===o.length){const e=r.correlation(n,o);i.push(e)}else i.push(0)}return i}detectDoji(e,t){return e.map((e,a)=>Math.abs(t[a]-e)/e<.001?1:0)}detectHammer(e,t,a,r){return e.map((e,i)=>{const s=Math.abs(r[i]-e),n=Math.min(e,r[i])-a[i],o=t[i]-Math.max(e,r[i]);return n>2*s&&o<s?1:0})}detectEngulfing(e,t){const a=[0];for(let r=1;r<e.length;r++){const i=Math.abs(t[r-1]-e[r-1]),s=Math.abs(t[r]-e[r]);t[r-1]<e[r-1]&&t[r]>e[r]&&e[r]<t[r-1]&&t[r]>e[r-1]&&s>i?a.push(1):t[r-1]>e[r-1]&&t[r]<e[r]&&e[r]>t[r-1]&&t[r]<e[r-1]&&s>i?a.push(-1):a.push(0)}return a}detectSupportResistance(e,t){const a=[],r=[];for(let i=t;i<e.length;i++){const s=e.slice(i-t,i),n=e[i],o=Math.min(...s);a.push(o/n);const l=Math.max(...s);r.push(l/n)}return{support:a,resistance:r}}calculateTrendStrength(e,t){const a=[];for(let i=t-1;i<e.length;i++){const s=e.slice(i-t+1,i+1),n=Array.from({length:t},(e,t)=>t),o=r.correlation(n,s);a.push(o)}return a}calculateFourierFeatures(e,t){const a=[[],[]];for(let r=t-1;r<e.length;r++){const i=e.slice(r-t+1,r+1);let s=0,n=0;for(let e=0;e<i.length;e++){const t=-2*Math.PI*e/i.length;s+=i[e]*Math.cos(t),n+=i[e]*Math.sin(t)}a[0].push(s/i.length),a[1].push(n/i.length)}return a}calculateCyclicalFeatures(e){const t=[],a=[5,20,60];for(const r of a){const a=[];for(let t=0;t<e.length;t++){const e=2*Math.PI*t/r;a.push(Math.sin(e))}t.push(a)}return t}},e.INDICATORS_CONFIG={SMA:{defaultPeriods:[5,10,20,50,100,200],minPeriod:2,maxPeriod:500},EMA:{defaultPeriods:[5,10,20,50,100,200],minPeriod:2,maxPeriod:500},WMA:{defaultPeriods:[5,10,20,50,100],minPeriod:2,maxPeriod:200},RSI:{defaultPeriod:14,alternativePeriods:[7,9,14,21,25],overboughtLevel:70,oversoldLevel:30,minPeriod:2,maxPeriod:100},MACD:{fastPeriod:12,slowPeriod:26,signalPeriod:9,alternativeSettings:[{fast:5,slow:35,signal:5},{fast:8,slow:17,signal:9},{fast:12,slow:26,signal:9}]},STOCHASTIC:{kPeriod:14,dPeriod:3,smoothing:3,overboughtLevel:80,oversoldLevel:20,alternativeSettings:[{k:5,d:3},{k:14,d:3},{k:21,d:5}]},WILLIAMS_R:{defaultPeriod:14,alternativePeriods:[7,14,21],overboughtLevel:-20,oversoldLevel:-80},CCI:{defaultPeriod:20,alternativePeriods:[14,20,50],overboughtLevel:100,oversoldLevel:-100,constant:.015},BOLLINGER_BANDS:{period:20,multiplier:2,alternativeSettings:[{period:10,multiplier:1.9},{period:20,multiplier:2},{period:50,multiplier:2.1}]},ATR:{defaultPeriod:14,alternativePeriods:[7,14,21,50],minPeriod:2,maxPeriod:100},ADX:{defaultPeriod:14,alternativePeriods:[7,14,21],trendThreshold:25,strongTrendThreshold:40},PARABOLIC_SAR:{accelerationFactor:.02,maxAcceleration:.2,alternativeSettings:[{af:.01,max:.1},{af:.02,max:.2},{af:.03,max:.3}]},OBV:{},MFI:{defaultPeriod:14,alternativePeriods:[10,14,20],overboughtLevel:80,oversoldLevel:20},VWAP:{resetPeriod:"session"},MOMENTUM:{defaultPeriod:10,alternativePeriods:[5,10,20,50]},ROC:{defaultPeriod:10,alternativePeriods:[5,10,20,50]},STANDARD_DEVIATION:{defaultPeriod:20,alternativePeriods:[10,20,50]},VARIANCE:{defaultPeriod:20,alternativePeriods:[10,20,50]},LINEAR_REGRESSION_SLOPE:{defaultPeriod:14,alternativePeriods:[7,14,21,50]}},e.MathUtils=r,e.StatisticsUtils=a,e.TechnicalIndicators=o,e.UltraPrecisionPredictor=class{constructor(e={}){this.models=[],this.isTrained=!1,this.featureImportance=[],this.trainingMetrics=null,this.lastConfidence=0,this.modelWeights=[],this.options={...i,...e}}async train(e){console.log(`🚀 Training Ultra-Precision Predictor with ${e.length} samples...`);const a=t.validateTrainingData(e);if(!a.isValid)throw new Error(`Training data validation failed: ${a.errors.map(e=>e.message).join(", ")}`);const{features:r,targets:i}=this.prepareTrainingData(e);console.log(`✨ Prepared ${r.length} samples with ${r[0]?.length||0} features`);const{trainX:s,trainY:n,testX:o,testY:l}=this.splitData(r,i),c=Date.now();await this.trainEnsemble(s,n);const h=Date.now()-c,u=await this.predictBatch(o);return this.trainingMetrics=this.calculateMetrics(u,l),this.calculateFeatureImportance(r[0]?.length||0),console.log(`📊 Training completed in ${h}ms:`),console.log(`   MAE: ${(100*this.trainingMetrics.mae).toFixed(3)}%`),console.log(`   RMSE: ${(100*this.trainingMetrics.rmse).toFixed(3)}%`),console.log(`   R²: ${this.trainingMetrics.r2.toFixed(4)}`),console.log(`   Directional Accuracy: ${(100*this.trainingMetrics.directionalAccuracy).toFixed(1)}%`),this.isTrained=!0,this.trainingMetrics.mae<=this.options.targetErrorRate?console.log(`🎯 Target error rate achieved: ${(100*this.trainingMetrics.mae).toFixed(3)}% <= ${(100*this.options.targetErrorRate).toFixed(1)}%`):console.log("⚠️  Target error rate not achieved. Consider increasing ensemble size or feature count."),{trainingMetrics:this.trainingMetrics,validationMetrics:this.trainingMetrics,trainingTime:h,featureCount:r[0]?.length||0,featureImportance:[...this.featureImportance]}}async predict(e){if(!this.isTrained)throw new Error("Model must be trained before making predictions");const a=t.validateFeatures(e);if(!a.isValid)throw new Error(`Feature validation failed: ${a.errors.map(e=>e.message).join(", ")}`);const r=this.models.map((t,a)=>{try{return this.predictWithModel(t,e,a)}catch(e){return console.warn(`Model ${a} prediction failed:`,e),0}}),i=this.combinepredictions(r);return this.lastConfidence=this.calculatePredictionConfidence(r),i}async predictBatch(e){if(!this.isTrained)throw new Error("Model must be trained before making predictions");const t=[];for(const a of e){const e=await this.predict(a);t.push(e)}return t}getConfidence(){return this.lastConfidence}getFeatureImportance(){return[...this.featureImportance]}getTrainingMetrics(){return this.trainingMetrics}isModelTrained(){return this.isTrained}async saveModel(){if(!this.isTrained)throw new Error("Cannot save untrained model");const e={version:"2.0.0",options:this.options,models:this.models.map(e=>this.serializeModel(e)),modelWeights:this.modelWeights,featureImportance:this.featureImportance,trainingMetrics:this.trainingMetrics,timestamp:(new Date).toISOString()};return JSON.stringify(e,null,2)}async loadModel(e){try{const t=JSON.parse(e);this.options={...this.options,...t.options},this.modelWeights=t.modelWeights||[],this.featureImportance=t.featureImportance||[],this.trainingMetrics=t.trainingMetrics,this.models=t.models.map(e=>this.deserializeModel(e)),this.isTrained=this.models.length>0,console.log(`✅ Model loaded successfully (${this.models.length} ensemble models)`)}catch(e){throw new Error(`Failed to load model: ${e}`)}}prepareTrainingData(e){const t=[],a=[];for(let r=0;r<e.length-1;r++){const i=e[r],s=e[r+1];let n;n=i.features&&i.features.length>0?i.features:this.generateBasicFeatures(e,r);const o=void 0!==i.target?i.target:(s.close-i.close)/i.close;n.length>0&&isFinite(o)&&(t.push(n),a.push(o))}return{features:t,targets:a}}generateBasicFeatures(e,t){const r=[],i=e[t];r.push((i.high-i.low)/i.close,(i.close-i.open)/i.open,i.volume/1e6);const s=[5,10,20];for(const n of s)if(t>=n){const s=e.slice(t-n+1,t+1).map(e=>e.close),o=a.mean(s);r.push((i.close-o)/o)}else r.push(0);for(let a=1;a<=5;a++)if(t>=a){const s=e[t-a].close;r.push((i.close-s)/s)}else r.push(0);return r}splitData(e,t){const a=e.length,r=Math.floor(a*this.options.trainingRatio),i=e.slice(0,r),s=e.slice(r);return{trainX:i,trainY:t.slice(0,r),testX:s,testY:t.slice(r)}}async trainEnsemble(e,t){this.models=[],this.modelWeights=[];for(let a=0;a<this.options.ensembleSize;a++){console.log(`Training model ${a+1}/${this.options.ensembleSize}...`);const r=await this.trainSingleModel(e,t,a),i=this.calculateModelWeight(r,e,t);this.models.push(r),this.modelWeights.push(i)}const r=a.sum(this.modelWeights);this.modelWeights=r>0?this.modelWeights.map(e=>e/r):new Array(this.models.length).fill(1/this.models.length)}async trainSingleModel(e,t,a){const{sampledX:r,sampledY:i}=this.bootstrapSample(e,t,a),s=this.trainLinearRegression(r,i);return{type:"linear",coefficients:s.coefficients,intercept:s.intercept,seed:42*a}}trainLinearRegression(e,t){const i=e.length,s=e[0]?.length||0;if(0===i||0===s)return{coefficients:[],intercept:0};e.map(e=>[1,...e]);const n=new Array(s).fill(0);let o=a.mean(t);for(let a=0;a<s;a++){const i=e.map(e=>e[a]),s=r.correlation(i,t);n[a]=.1*s}return{coefficients:n,intercept:o}}bootstrapSample(e,t,a){const r=e.length,i=[],s=[];let n=a;const o=()=>(n=(9301*n+49297)%233280,n/233280);for(let a=0;a<r;a++){const a=Math.floor(o()*r);i.push([...e[a]]),s.push(t[a])}return{sampledX:i,sampledY:s}}calculateModelWeight(e,t,r){const i=t.map(t=>this.predictWithModel(e,t,0)),s=a.mean(i.map((e,t)=>Math.pow(e-r[t],2)));return s>0?1/(1+s):1}predictWithModel(e,t,a){if("linear"===e.type){let a=e.intercept;for(let r=0;r<Math.min(t.length,e.coefficients.length);r++)a+=t[r]*e.coefficients[r];return a}return 0}combinepredictions(e){if(0===e.length)return 0;let t=0,r=0;for(let a=0;a<e.length;a++){const i=this.modelWeights[a]||1/e.length;t+=e[a]*i,r+=i}return r>0?t/r:a.mean(e)}calculatePredictionConfidence(e){if(0===e.length)return 0;const t=a.mean(e),r=a.standardDeviation(e)/(Math.abs(t)+1e-8);return Math.max(0,Math.min(1,1-r))}calculateFeatureImportance(e){this.featureImportance=new Array(e).fill(0);for(const t of this.models)if(t.coefficients)for(let a=0;a<Math.min(e,t.coefficients.length);a++)this.featureImportance[a]+=Math.abs(t.coefficients[a]);const t=a.sum(this.featureImportance);t>0&&(this.featureImportance=this.featureImportance.map(e=>e/t))}calculateMetrics(e,t){const r=Math.min(e.length,t.length);if(0===r)return{mae:1,mse:1,rmse:1,r2:0,directionalAccuracy:.5,sampleCount:0};const i=e.slice(0,r),s=t.slice(0,r),n=a.mean(i.map((e,t)=>Math.abs(e-s[t]))),o=a.mean(i.map((e,t)=>Math.pow(e-s[t],2))),l=Math.sqrt(o),c=a.mean(s),h=a.sum(s.map(e=>Math.pow(e-c,2))),u=a.sum(i.map((e,t)=>Math.pow(s[t]-e,2)));return{mae:n,mse:o,rmse:l,r2:h>0?1-u/h:0,directionalAccuracy:i.filter((e,t)=>e>0&&s[t]>0||e<0&&s[t]<0||Math.abs(e)<1e-8&&Math.abs(s[t])<1e-8).length/r,sampleCount:r}}serializeModel(e){return{type:e.type,coefficients:e.coefficients,intercept:e.intercept,seed:e.seed}}deserializeModel(e){return{type:e.type,coefficients:e.coefficients||[],intercept:e.intercept||0,seed:e.seed||0}}},e.VERSION="2.0.0",e.ValidationUtils=t});
//# sourceMappingURL=meridianalgo-js.umd.min.js.map
